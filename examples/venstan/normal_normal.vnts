// Copyright (c) 2015 MIT Probabilistic Computing Project.
//
// This file is part of Venture.
//
// Venture is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Venture is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Venture.  If not, see <http://www.gnu.org/licenses/>.

// A slightly contrived example of a joint VentureScript-Stan model.

// The model supposes an unknown parameter theta, with a Gaussian
// prior and Gaussian observation noise.  Stan is doing inference on
// the location of the variable, and VentureScript is inferring the
// variance of the noise, from a discrete prior implying that the
// variance may be either relatively small or relatively large.

infer load_plugin("venstan.py");
assume stan_prog = "
data {
  int N;
  real<lower=0> sigma;
  real y[N];
}
parameters {
  real mu;
}
model {
  increment_log_prob(normal_log(mu, 0, 1));
  for (n in 1:N)
    increment_log_prob(normal_log(y[n], mu, sigma));
}
generated quantities {
  real y_out[N];
  for (n in 1:N)
    y_out[n] <- normal_rng(mu, sigma);
}";
assume inputs = list(list("N", "Int"), list("sigma", "Number"));
assume c_outputs = list(list("y_out", "y", "UArray(Number)", "N"));
assume stan_sp = make_ven_stan(stan_prog, inputs, c_outputs);
assume large_noise = flip();
assume variance = if (large_noise) { 10 } else { 1 };

// With the given prior on mu, making these observations 8 should
// heavily favor the "large" result, whereas making them 0 should heavily
// favor the "not large" result.
observe stan_sp(5, variance) = vector(8, 8, 8, 8, 8);
define data = run(accumulate_dataset(20, {
  reset_to_prior;
  mh(default, one, 20);
  collect(large_noise)}));
print(data)
