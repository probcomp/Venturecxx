# Copyright (c) 2014, 2015 MIT Probabilistic Computing Project.
#
# This file is part of Venture.
#
# Venture is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Venture is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Venture.  If not, see <http://www.gnu.org/licenses/>.

# Poor man's version of Scheme's syntax-rules pattern language.
# See the SyntaxRule class.

from venture.exception import VentureException
from venture.sivm.macro_system import Macro
from venture.sivm.macro_system import Syntax
from venture.sivm.macro_system import expand
from venture.sivm.macro_system import getSym
from venture.sivm.macro_system import isSym

def traverse(exp):
  if isinstance(exp, list):
    for i, e in enumerate(exp):
      for j, f in traverse(e):
        yield [i] + j, f
  else: yield [], exp

def bind(pattern, exp):
  if isinstance(pattern, list):
    bindings = {}
    for i, p in enumerate(pattern):
      bindings.update(bind(p, exp[i]))
    return bindings
  return {pattern: exp}

def sub(bindings, template):
  if isinstance(template, list):
    return [sub(bindings, t) for t in template]
  if isSym(template) and template in bindings:
    return bindings[template]
  return template

def verify(pattern, exp, context):
  """Verifies that the given expression matches the pattern in form."""
  if isinstance(pattern, list):
    if not isinstance(exp, list):
      raise VentureException('parse',
        'Invalid expression in %s -- expected list!' % (context,),
        expression_index=[])
    if len(exp) != len(pattern):
      raise VentureException('parse',
        'Invalid expression in %s -- expected length %d' %
          (context, len(pattern)),
        expression_index=[])
    for index, (p, e) in enumerate(zip(pattern, exp)):
      try:
        verify(p, e, context)
      except VentureException as err:
        err.data['expression_index'].insert(0, index)
        raise

class SyntaxRule(Macro):
  """A poor man's version of Scheme's syntax-rules pattern language for defining macros.

Does not support:
- literal tokens in patterns
- multiple alternate pattern-template pairs for the same macro
- pattern repetition notation (the ellipses "..." that novice
  syntax-rules users find so wonderfully confusing)
- hygiene (operates on expressions with symbols, which are eventually
  interpreted in the macro use site environment)

What's left?
- Patterns are (nested) lists of symbols.
  - pattern[0] must be a symbol and is taken to be the name of the
    macro
  - all other pattern symbols bind the corresponding code fragments at
    the use site
- Templates are nested lists of symbols.
- The output is the template, except that symbols bound in the pattern
  are replaced by those code fragments from the use site (symbols that
  are not bound are inserted as is).

This is sufficient to transform expression indexes between an
expression matching the pattern and one generated by the template.
Fancier features of syntax-rules may be implemented as an expander
function that computes the desired pattern-template pair, dynamically
constructs a SyntaxRule object, and expands with that.

  """
  def __init__(self, pattern, template, desc=None, intended_for_inference=False):
    super(SyntaxRule, self).__init__(desc=desc, intended_for_inference=intended_for_inference)
    self.name = pattern[0]
    self.pattern = pattern
    self.template = template
    self.desc = desc

    patternIndeces = {sym: index for index, sym in traverse(pattern) if isSym(sym)}
    templateIndeces = {sym: index for index, sym in traverse(template) if isSym(sym)}

    self.desugar = lambda index: replace(pattern, templateIndeces, index)
    self.resugar = lambda index: replace(template, patternIndeces, index)

  def applies(self, exp):
    return isinstance(exp, list) and len(exp) > 0 and getSym(exp[0]) == self.name

  def expand(self, exp):
    verify(self.pattern, exp, self.pattern[0])
    try:
      bindings = bind(self.pattern, exp)
      subbed = sub(bindings, self.template)
      expanded = expand(subbed)
      return SubstitutionSyntax(expanded, self.desugar, self.resugar)
    except VentureException as e:
      e.data['expression_index'] = self.resugar(e.data['expression_index'])
      raise

def replace(exp, indexMap, index):
  i = 0
  while isinstance(exp, list):
    if i == len(index):
      return []
    exp = exp[index[i]]
    i += 1

  if isSym(exp) and exp in indexMap:
    return indexMap[exp] + index[i:]

  return []

class SubstitutionSyntax(Syntax):
  def __init__(self, syntax, desugar, resugar):
    self.syntax = syntax
    self.desugar = desugar
    self.resugar = resugar
  def desugared(self):
    return self.syntax.desugared()
  def desugar_index(self, index):
    index = self.desugar(index)
    return self.syntax.desugar_index(index)
  def resugar_index(self, index):
    index = self.syntax.resugar_index(index)
    return self.resugar(index)
